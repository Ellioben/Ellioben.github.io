[{"categories":["Tools"],"content":"AI绘画 💭","date":"2022-04-07","objectID":"/aidraw/","tags":["design","AI"],"title":"AIdraw","uri":"/aidraw/"},{"categories":["Tools"],"content":"AI绘画的软件和平台有很多种，不同的平台对AI绘画的限制也不同，现在主要介绍Google的一个开源项目 注意：需要google drive colab 这个可以通过描述来绘画，害可以设置图片分辨率，图片大小。 英语不好的同学可以通过google翻译来翻译自己想说的话，放在上面 没错，肉眼不可见的速度 生成画作的流程大概分为这几步： 打开程序； 设置图片尺寸 过程图张数 生成图张数等参数 用英文写好描述词（Prompts），格式大致为“画作类型 + 对象（可以有多个）+ 画风设定 + 一些起限定作用的修辞词” 开始运行，等待 AI 渲染画作。 执行run all 我给 AI 写的描述词：“A beautiful painting of a starry night, shining its light across a sunflower sea by James Gurney, Trending on artstation.” ","date":"2022-04-07","objectID":"/aidraw/:0:0","tags":["design","AI"],"title":"AIdraw","uri":"/aidraw/"},{"categories":["Tools"],"content":"扩展 还有其他推荐的网站/app，有兴趣的可以试试 https://www.chinaz.com/2022/0825/1437982.shtml ","date":"2022-04-07","objectID":"/aidraw/:1:0","tags":["design","AI"],"title":"AIdraw","uri":"/aidraw/"},{"categories":["Develop"],"content":"desc","date":"2022-10-21","objectID":"/go%E7%9A%84mpg%E6%A8%A1%E5%9E%8B/","tags":["go","并发"],"title":"Go的MPG模型","uri":"/go%E7%9A%84mpg%E6%A8%A1%E5%9E%8B/"},{"categories":["Develop"],"content":"在操作系统提供的内核线程之上，Go搭建了一个特有的两级线程模型。goroutine机制实现了M:N的线程模型，goroutine机制是协程（coroutine）的一种实现，golang内置的调度器，可以让多核CPU中每个CPU执行一个协程。 ","date":"2022-10-21","objectID":"/go%E7%9A%84mpg%E6%A8%A1%E5%9E%8B/:0:0","tags":["go","并发"],"title":"Go的MPG模型","uri":"/go%E7%9A%84mpg%E6%A8%A1%E5%9E%8B/"},{"categories":["Develop"],"content":"调度器是如何工作的 有了上面的认识，可以开始真正的介绍Go的并发机制了，先用一段代码展示一下在Go语言中新建一个“线程“（Go语言中称为Goroutine）的样子： //1用go关键字加上一个函数（这里用了匿名函数） //调用就做到了在一个新的“线程”并发执行任务 go func() { }() 理解goroutine机制的原理，关键是理解Go语言scheduler的实现。 Go语言中支撑整个scheduler实现的主要有4个重要结构，分别是M、P、G、Sched，前三个定义在runtime.h中，Sched定义在proc.c中。 ","date":"2022-10-21","objectID":"/go%E7%9A%84mpg%E6%A8%A1%E5%9E%8B/:0:1","tags":["go","并发"],"title":"Go的MPG模型","uri":"/go%E7%9A%84mpg%E6%A8%A1%E5%9E%8B/"},{"categories":["Develop"],"content":"desc","date":"2022-10-21","objectID":"/closure%E9%97%AD%E5%8C%85/","tags":["xxx"],"title":"Closure","uri":"/closure%E9%97%AD%E5%8C%85/"},{"categories":["Develop"],"content":"闭包 闭包就是一个函数和与其相关的引用环境组合的一个整体 闭包就是返回的匿名函数+匿名函数以外的变量sum 感受：匿名函数中引用的那个变量会一直保存在内存中，可以一直使用 函数在创建的时候会创建两个对象，一个是函数对象本身，另一个是作用域链对象 函数在调用的时候会创建一个执行环境对象（活动对象） 返回值是内存函数（实际是内层函数地址） 内层函数涉及到方法中的i import \"fmt\" func main() { f := getSum() fmt.Println(getSum()) fmt.Println(f(100)) fmt.Println(f(2)) fmt.Println(f(3)) } func getSum() func(int) int { var sum = 0 return func(num int) int { sum = num+sum return sum } } //===-== 0x49aa70 100 102 105 ","date":"2022-10-21","objectID":"/closure%E9%97%AD%E5%8C%85/:1:0","tags":["xxx"],"title":"Closure","uri":"/closure%E9%97%AD%E5%8C%85/"},{"categories":["Develop"],"content":"注意 1、中使用的变量/参数会一直保存在内存中，所以会一直使用—\u003e意味着闭包不可滥用 2、闭包的用处 （1）可以读取函数内部的变量 （2）让这些变量始终保持在内存中 （3）封装对象的私有属性和私有方法 （4）延长变量的生命周期 3、为什么要使用闭包 定义了一个全局变量，每次累加都是更新这个全局变量，but编程语言有一条不成文的铁律，就是尽可能少定义全局变量 全局变量难以控制，可以在任何地方进行读写，意味着可能会被不相干的程序改写。 回收机制会每隔一段时间进行一次回收操作，释放不需要被占用的内存。一般局部变量（定义在函数中的变量），在函数调用完成后与之对应的执行环境会被推出执行栈。而全局变量因为随时可以被任何程序在任何地方读写，所以回收机制很难统计何时需要释放全局变量所占用的内存，也就导致全局变量一般是在全局执行环境被销毁时才会释放，占用内存的生命周期长。 (当我们需要重复使用一个对象，但又想保护这个对象不被其他代码污染。) ","date":"2022-10-21","objectID":"/closure%E9%97%AD%E5%8C%85/:2:0","tags":["xxx"],"title":"Closure","uri":"/closure%E9%97%AD%E5%8C%85/"},{"categories":["Develop"],"content":"意义 Go 函数可以是一个闭包。闭包是一个函数值，它引用了函数体之外的变量。 这个函数可以对这个引用的变量进行访问和赋值；换句话说这个函数被“绑定”在这个变量上。 我的不靠谱的理解，一个闭包相当于一个类的实例，函数体之外的变量相当于这个实例存储的变量。 没有闭包的时候，函数就是一次性买卖，函数执行完毕后就无法再更改函数中变量的值（应该是内存释放了）；有了闭包后函数就成为了一个变量的值，只要变量没被释放，函数就会一直处于存活并独享的状态，因此可以后期更改函数中变量的值（因为这样就不会被go给回收内存了，会一直缓存在那里）。 从上面的示例中我们可以看出闭包的两个核心作用： 在函数外部访问函数内部变量成为可能 函数内部变量离开其作用域后始终保持在内存中而不被销毁 ","date":"2022-10-21","objectID":"/closure%E9%97%AD%E5%8C%85/:3:0","tags":["xxx"],"title":"Closure","uri":"/closure%E9%97%AD%E5%8C%85/"},{"categories":["Mac","Tools"],"content":"desc","date":"2022-10-09","objectID":"/mactool/","tags":["mac","tools"],"title":"mac/linux好用的工具","uri":"/mactool/"},{"categories":["Mac","Tools"],"content":"mac/linux好用的工具 ","date":"2022-10-09","objectID":"/mactool/:0:0","tags":["mac","tools"],"title":"mac/linux好用的工具","uri":"/mactool/"},{"categories":["Mac","Tools"],"content":"crontab 1、Linux和Mac下操作crontab都是一致的 2、配置文件都在/etc/crontab下，如果没有就创建。 3、crontab参数 crontab [-u user] file crontab [-u user] [ -e | -l | -r ] -u user：用来设定某个用户的crontab服务； file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。 -e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。 -l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。 -r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。 -i：在删除用户的crontab文件时给确认提示。 4、配置环境变量，打开open ~/.bash_profile文件添加以下内容; EDITOR=vim crontab -e；export EDITOR 5、crontab的文件格式 eg：* * * * * sh /xxxxx/davecron.sh \u003e\u003e/xxxxx/davecron.log ","date":"2022-10-09","objectID":"/mactool/:1:0","tags":["mac","tools"],"title":"mac/linux好用的工具","uri":"/mactool/"},{"categories":["Mac","Tools"],"content":"查看当前的cron job sudo crontab -l 35 22 * * * /Users/xxx/shell/openSafari.sh ","date":"2022-10-09","objectID":"/mactool/:1:1","tags":["mac","tools"],"title":"mac/linux好用的工具","uri":"/mactool/"},{"categories":["Mac","Tools"],"content":"添加cron job sudo crontab -e 35 22 * * * /Users/xxx/shell/openSafari.sh #编辑或添加需要执行的时间和任务 * 第1列分钟0～59 * 第2列小时0～23（0表示子夜） * 第3列日1～31 * 第4列月1～12 * 第5列星期0～7（0和7表示星期天） * 第6列要运行的命令 #添加完成查看 sudo crontab -l ","date":"2022-10-09","objectID":"/mactool/:1:2","tags":["mac","tools"],"title":"mac/linux好用的工具","uri":"/mactool/"},{"categories":["Develop"],"content":"desc","date":"2022-10-07","objectID":"/smartcontract/","tags":["smartcontract","blockchain"],"title":"SmartContract","uri":"/smartcontract/"},{"categories":["Develop"],"content":"SmartContract 中文名称智能合约 了解智能合约签，现需要了解以太坊。 ","date":"2022-10-07","objectID":"/smartcontract/:0:0","tags":["smartcontract","blockchain"],"title":"SmartContract","uri":"/smartcontract/"},{"categories":["Develop"],"content":"以太坊中重要概念 账户(Account) 包含地址，余额和随机数，以及可选的存储和代码的对象。 普通账户(EOA) ，存储和代码均为空 合约账户(Contract)，包含存储和代码 地址(Address) 般来说，这代表一个EOA或合约，它可以在区块链上接收或发送交易。更具体地说，它是ECDSA公钥的keccak散列的最右边的160位。 交易(Transaction) 可以发送以太币和信息 向合约发送的交易可以调用合约代码，并以信息数据为函数参数 向空用户发送信息，可以自动生成以信息为代码块的合约账户 gas 以太坊用于执行智能合约的虚拟燃料。以太坊虚拟机使用核算机制来衡量 gas的消耗量并限制计算资源的消耗。 ","date":"2022-10-07","objectID":"/smartcontract/:1:0","tags":["smartcontract","blockchain"],"title":"SmartContract","uri":"/smartcontract/"},{"categories":["Develop"],"content":"以太坊特点 以太坊是“世界计算机”，这代表它是一个开源的、全球分布的计算基础设施 执行称为智能合约(smart contract)的程序 使用区块链来同步和存储系统状态以及名为以太币(ether)的加密货币，以计量和约束执行资源成本 本质是一个基于交易的状态机(transaction-based state machine) 以太坊平台使开发人员能够构建具有内置经济功能的强大去中心化应用程序(DApp)；在持续自我正常运行的同时，它还减少或消除了审查，第三方界面和交易对手风险 ","date":"2022-10-07","objectID":"/smartcontract/:2:0","tags":["smartcontract","blockchain"],"title":"SmartContract","uri":"/smartcontract/"},{"categories":["Develop"],"content":"名词解释 ERC: Ethereum Request for Comments的缩写,以太坊征求意见.些EIP被标记为ERC，表示试图定义以太坊使用的特定标准的提议 EOA： External Owned Accoupt，外部账户。由以太坊网络的人类用户创建的账户 Keccak256：以太坊中使用的密码哈希函数。Keccak256被标准化为 SHA-3 Nonce：在密码学中，术语nonce用于指代只能使用一次的值。以太坊使用两种类型的随机数，账户随机数和POW随机数 ","date":"2022-10-07","objectID":"/smartcontract/:3:0","tags":["smartcontract","blockchain"],"title":"SmartContract","uri":"/smartcontract/"},{"categories":["Develop"],"content":"Smart Contract etherscan.io可以看到现在主网络上的合约交易记录。 ","date":"2022-10-07","objectID":"/smartcontract/:4:0","tags":["smartcontract","blockchain"],"title":"SmartContract","uri":"/smartcontract/"},{"categories":["Develop"],"content":"Remix 合约开发工具Remix（基于浏览器的Solidity在线编辑器） 合约都是solidity编写的，有必要学习一下solidity语法。 VS code 下载Remix插件 http://remix.ethereum.org/ 在线 docker启动 docker run -p 10330:80 remixproject/remix-ide:latest ","date":"2022-10-07","objectID":"/smartcontract/:4:1","tags":["smartcontract","blockchain"],"title":"SmartContract","uri":"/smartcontract/"},{"categories":["Develop"],"content":"其他合约开发工具 MetaMask - 浏览器插件钱包 Geth - 以太坊客户端(go语言) web3.js - 以太坊 javascipt API库 Ganache-以太坊客户端(测试环境私链) Truffle- 以太坊开发框架 Tenderly - Comprehensive Ethereum developer platform for real-time monitoring, alerting, debugging, and simulating smart contracts. Openzeppelin - 好用的Library https://docs.openzeppelin.com/contracts/4.x/wizard ","date":"2022-10-07","objectID":"/smartcontract/:4:2","tags":["smartcontract","blockchain"],"title":"SmartContract","uri":"/smartcontract/"},{"categories":["Develop"],"content":"合约部署测试 // SPDX-License-Identifier: GPL-3.0 pragma solidity \u003e=0.7.0 \u003c0.9.0; /** * @title Storage * @dev Store \u0026 retrieve value in a variable */ contract Storage { uint256 number; function store(uint256 num) public { number = num; } function retrieve() public view returns (uint256){ return number; } } DEPLOY\u0026RUN 可以通过测试方法进行输入参数和合约进行交互 ","date":"2022-10-07","objectID":"/smartcontract/:4:3","tags":["smartcontract","blockchain"],"title":"SmartContract","uri":"/smartcontract/"},{"categories":["Develop"],"content":"查看合约功能 通过查看ABI来查看合约提供的功能。 输出ABI [ { \"inputs\": [ { \"internalType\": \"uint256\", \"name\": \"num\", \"type\": \"uint256\" } ], \"name\": \"store\", \"outputs\": [], \"stateMutability\": \"nonpayable\", \"type\": \"function\" }, { \"inputs\": [], \"name\": \"retrieve\", \"outputs\": [ { \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" } ], \"stateMutability\": \"view\", \"type\": \"function\" } ] ","date":"2022-10-07","objectID":"/smartcontract/:4:4","tags":["smartcontract","blockchain"],"title":"SmartContract","uri":"/smartcontract/"},{"categories":["Develop"],"content":"Web3 前端创建web3交互搭建 准备：安装google插件 MateMask // \u003cscript src=\"web3.min.js\"\u003e\u003c/script\u003e \u003cdiv\u003e \u003cbutton id=\"eth_requestAccounts\"\u003e链接钱包\u003c/button\u003e \u003c/div\u003e jQuery(\"#eth_requestAccounts\").click(async function () { if (typeof window.ethereum !== 'undefined') { let address=await ethereum.request({ method: 'eth_requestAccounts' });//授权连接钱包 console.log('用户钱包地址:',address[0]);//第一个是meatmask的所有钱包 }else{ console.log('未安装钱包插件！'); } // ADDR = await ethereum.request({ method: 'eth_requestAccounts' }); // alert(\"连接Mask成功\",ADDR) }); 实例化web3 // 设置 web3 实例 const web3 = new Web3(\"ws://localhost:7545\") //合约地址 const Token = '0x06CE5a080b2a897dF3488150D2aD5440c334a423' // 获取所有的账户，用作后面发起交易时的账户 const accounts = await web3.eth.personal.getAccounts(); console.log(\"Test Wallet: \",accounts) // 载入合约 const contract = new web3.eth.Contract(ABI, Token); // 调用ABI contract.methods.store(666) contract.methods.retrieve() ","date":"2022-10-07","objectID":"/smartcontract/:4:5","tags":["smartcontract","blockchain"],"title":"SmartContract","uri":"/smartcontract/"},{"categories":["Develop"],"content":"编写合约 准备工作 学习solidity语法 学习常见的合约ERC20，REC721，REC1155 Ethereum Request for Comment (ERC)，定义了符合规范的smart contract 学习测试网/模拟测试网工具使用 后续有时间会补充solidity相关的… ","date":"2022-10-07","objectID":"/smartcontract/:5:0","tags":["smartcontract","blockchain"],"title":"SmartContract","uri":"/smartcontract/"},{"categories":["Develop"],"content":"desc","date":"2022-09-22","objectID":"/blockchain/","tags":["blockchain"],"title":"Blockchain","uri":"/blockchain/"},{"categories":["Develop"],"content":" 区块链上的东西本来就是概念上的东西偏多，这偏都是一些概念类比性的东西，有兴趣可以看看。待更新… 区块链 区块链是什么？ (1)数据角度：一种几乎不可能被更改的分布式数据库。 “分布式”特点： 1、数据的分布式存储：存储在所有参与记录数据的节点中， 并非集中存储在中心化的机构节点中。 2、数据的分布式记录：系统参与者共同维护。去中心化数据库 三、区块链技术涉及关键点 (1)去中心化 (2)去信任 (3)集体维护 (4)可靠数据库 (5)时间截 (6)非对称加密 ","date":"2022-09-22","objectID":"/blockchain/:0:0","tags":["blockchain"],"title":"Blockchain","uri":"/blockchain/"},{"categories":["Develop"],"content":"区块链概述 区块链定义： 区块链 是一个共享的、不可篡改的账本，旨在促进业务网络中的交易记录和资产跟踪流程。 资 产 可以是有形的（如房屋、汽车、现金、土地），也可以是无形的（如知识产权、专利、版权、品牌）。 几乎任何有价值的东西都可以在区块链网络上进行跟踪和交易，从而降低各方面的风险和成本。 **为什么说区块链很重要：**业务运行依靠信息。 信息接收速度越快，内容越准确，越有利于业务运营。 区块链是用于传递这些信息的理想之选，因为它可提供即时、共享和完全透明的信息，这些信息存储在不可篡改的账本上，只能由获得许可的网络成员访问。 区块链网络可跟踪订单、付款、帐户、生产等信息。 由于成员之间共享单一可信视图，因此，您可以端到端地查看交易的所有细节，从而赋予您更大的信心和机会，并提高效率 ","date":"2022-09-22","objectID":"/blockchain/:1:0","tags":["blockchain"],"title":"Blockchain","uri":"/blockchain/"},{"categories":["Develop"],"content":"区块链的关键元素 分布式账本技术 所有网络参与者都有权访问分布式账本及其不可篡改的交易记录。 使用此共享账本，交易仅需记录一次，从而消除了传统业务网络中典型的重复工作。 不可篡改的记录 在交易被记录到共享账本之后，任何参与者都不可以更改或篡改交易。 如果交易记录中 有 错误，则必须添加新交易才能撤消该错误，这两个交易随后都是可视的。 智能合同 为了加快交易速度，区块链上存储了一系列自动执行的规则，称为 “智能合约” 。 智能合约可以定义公司债券转让的条件，包括要支付的旅行保险条款等等。 ","date":"2022-09-22","objectID":"/blockchain/:1:1","tags":["blockchain"],"title":"Blockchain","uri":"/blockchain/"},{"categories":["Develop"],"content":"区块链的运作方式 每个交易发生时，都会被记录为一个数据\"块\" 这些交易表明资产的流动，资产可以是有形的（如产品），也可以是无形的（如知识产权）。 数据块可以记录您的首选信息项：谁、什么、何时、何地、多少甚至条件 — 例如食品运输温度。 每个块都连接到位于它前后的块 随着资产位置的改变或所有权的变更，这些数据块形成了数据链。 数据块可以确认交易的确切时间和顺序，通过将数据块安全地链接在一起，可以防止任何数据块被篡改或在两个现有数据块之间插入其他数据块。 交易被封闭在不可逆的链中：区块链 每添加一个数据块都会加强前一个块的验证，从而增强整条区块链。 这使得区块链能够防止篡改，提供不可更改的关键优势。 这不但消除了恶意人员进行篡改的可能性，而且还建立了您和其他网络成员可以信任的交易账本。 ","date":"2022-09-22","objectID":"/blockchain/:1:2","tags":["blockchain"],"title":"Blockchain","uri":"/blockchain/"},{"categories":["Develop"],"content":"区块链的优点 **需要变更的地方：**运营人员经常在重复保存记录和第三方验证上浪费精力。 记录保存系统容易受到欺诈和网络攻击的影响。 有限的透明度会减慢数据验证速度。 随着物联网的到来，交易量激增。 所有这些问题都会影响开展业务的速度和最终的盈利，因此我们需要更好的方法。 进入区块链。 更高的信任度 使用区块链，作为会员制网络中的一员，您可以确信自己收到的数据是准确的、及时的，并且您的机密区块链记录只能与您特别授予访问权限的网络成员共享。 更出色的安全性 所有的网络成员都需要就数据准确性达成共识，并且所有经过验证的交易都将永久记录在案，不可篡改。 没有人可以删除交易，即使是系统管理员也不例外。 更高的效率 通过在网络成员之间共享分布式账本，您可以避免在记录对账上浪费时间。 为了加快交易速度，区块链上存储了一系列自动执行的规则，称为\"智能合约\"。 ","date":"2022-09-22","objectID":"/blockchain/:2:0","tags":["blockchain"],"title":"Blockchain","uri":"/blockchain/"},{"categories":["Develop"],"content":"k8s/待更新...","date":"2022-09-22","objectID":"/k8s/","tags":["k8s","DevOps"],"title":"K8S","uri":"/k8s/"},{"categories":["Develop"],"content":" 待更新…… 全名Kubernetes（虚拟容器批量管理工具之一） 学习文档 https://kubernetes.io/zh-cn/docs/tasks/tools/ Kubernetes 作为一个容器集群管理系统，用于管理云平台中多个主机上的容器应用，Kubernetes 的目标是让部署容器化的应用变得简单且高效，所以 Kubernetes 提供了应用部署，规划，更新，维护的一整套完整的机制。 比起k8s是构建容器编排工具来说，在我看来k8s更像是一个虚拟服务容器级别的生态圈。 k8s服务架构 Master node k8s集群控制节点，对集群迸行调度管理，接受集群外用户去集群操作请求; Master node由 API Server、 Scheduler、 Cluster state store（ETCD数据库）和 Controller Manger Server所组成; Worker node 集群工作节点，运行用户业务应用容器; Worker Node包含 kubelet、 kube proxy和 Container Runtime; ","date":"2022-09-22","objectID":"/k8s/:0:0","tags":["k8s","DevOps"],"title":"K8S","uri":"/k8s/"},{"categories":["Develop"],"content":"准备 k8s是基于docker的。要先安装docker ","date":"2022-09-22","objectID":"/k8s/:1:0","tags":["k8s","DevOps"],"title":"K8S","uri":"/k8s/"},{"categories":["Develop"],"content":"Kubeadm 有多台vm推荐kubeadm安装k8s环境 ","date":"2022-09-22","objectID":"/k8s/:1:1","tags":["k8s","DevOps"],"title":"K8S","uri":"/k8s/"},{"categories":["Develop"],"content":"minikube 没有vm推荐使用minikube 安装minikube（在docker跑了个ubantu跑了个minikube的节点） brew install minikube #启动 minikube start https://k8s.easydoc.net/docs/dRiQjyTY/28366845/6GiNOzyZ/9EX8Cp45 ","date":"2022-09-22","objectID":"/k8s/:1:2","tags":["k8s","DevOps"],"title":"K8S","uri":"/k8s/"},{"categories":["Develop"],"content":"主节点需要组件 docker（也可以是其他容器运行时） kubectl 集群命令行交互工具 ","date":"2022-09-22","objectID":"/k8s/:2:0","tags":["k8s","DevOps"],"title":"K8S","uri":"/k8s/"},{"categories":["Develop"],"content":"工具 自己本地测试需要安装的工具 minikube kubectl k9s好用的dashboard（可选） brew install kubectl or brew install kubernetes-cli #测试一下，确保你安装的是最新的版本： kubectl version --client ","date":"2022-09-22","objectID":"/k8s/:3:0","tags":["k8s","DevOps"],"title":"K8S","uri":"/k8s/"},{"categories":["Develop"],"content":"常用的指令 #创建namespase kubectl create ns test # apply 创建一个k8s组建 kubectl apply -n test -f xxxx.yaml # kubectl get pods -n test # 查看 pod 对外的ip、 运行状态 kubectl get pod -o wide # get service kubectl get svc -n test # 编辑对应的配置文件 kubectl edit svc xxx-service -n test # 查看 log kubectl logs pod-name # 进入 Pod 容器终端， -c container-name 可以指定进入哪个容器。 kubectl exec -it pod-name -- bash # 如果这个pod有多个容器 kubectl exec -it pod-name -c container-name -- bash # 伸缩扩展副本 kubectl scale deployment xxx-deplyment --replicas=5 # 把集群内端口映射到节点 容器外port:容器里port kubectl port-forward pod-name 8090:8080 # 删除部署 kubectl delete deployment test-k8s ` ","date":"2022-09-22","objectID":"/k8s/:4:0","tags":["k8s","DevOps"],"title":"K8S","uri":"/k8s/"},{"categories":["Develop"],"content":"组件 ","date":"2022-09-22","objectID":"/k8s/:5:0","tags":["k8s","DevOps"],"title":"K8S","uri":"/k8s/"},{"categories":["Develop"],"content":"Pod 重要概念 PodK8S 调度、管理的最小单位，一个 Pod 可以包含一个或多个容器，每个 Pod 有自己的虚拟IP。一个工作节点可以有多个 pod，主节点会考量负载自动调度 pod 到哪个节点运行。 pod挂了会生成一个pod，新的pod的ip就变了。 通过 kubectl apply -f pod.yaml pod.yaml apiVersion: v1 kind: Pod metadata: name: test-pod spec: containers: - name: test-k8s image: ccr.ccs.tencentyun.com/k8s-tutorial/test-k8s:v1 pod生命周期 master节点 ​ createpod – api server– etcd ​ scheduler –（watch）– apiserver – etcd– 调度算法,把pod调度对应的node节点上 node节点 ​ kubelet –（watch）–apiserver – 读取etcd拿到分配给当前节点pod – docker创建容器 – 创建完成 – update pod status –apiserver – etcd ","date":"2022-09-22","objectID":"/k8s/:5:1","tags":["k8s","DevOps"],"title":"K8S","uri":"/k8s/"},{"categories":["Develop"],"content":"Service Service 通过 label 关联对应的 Pod Servcie 生命周期不跟 Pod 绑定，不会因为 Pod 重创改变 IP 提供了负载均衡功能，自动转发流量到不同 Pod 可对集群外部提供访问端口 集群内部可通过服务名字访问 kubectl apply -f service.yaml apiVersion: v1 kind: Service metadata: name: test-k8s spec: selector: app: test-k8s # (跟pod的lables关联的) type: ClusterIP ports: - port: 8080 # 本 Service 对外的端口 targetPort: 8080 # service访问内部容器的端口 kubectl get svc 查看服务详情 kubectl describe svc test-k8s， 可以发现 Endpoints 是各个 Pod 的 IP，也就是service会把流量转发到这些节点。 服务的默认类型是ClusterIP，只能在集群内部访问，我们可以进入到 Pod 里面访问： kubectl exec -it pod-name -- bash curl http://test-k8s:8080 如果要在集群外部访问，可以通过端口转发实现（只适合临时测试用）： kubectl port-forward service/test-k8s 8888:8080 如果你用 minikube，也可以这样minikube service test-k8s 对外暴露服务上面我们是通过端口转发的方式可以在外面访问到集群里的服务，如果想要直接把集群服务暴露出来，我们可以使用NodePort 和 Loadbalancer 类型的 Service apiVersion: v1 kind: Service metadata: name: test-k8s spec: selector: app: test-k8s type: NodePort ports: - port: 8080 # 本 Service 的端口 targetPort: 8080 # 容器端口 nodePort: 31000 # 添加节点端口，范围固定 30000 ~ 32767 ","date":"2022-09-22","objectID":"/k8s/:5:2","tags":["k8s","DevOps"],"title":"K8S","uri":"/k8s/"},{"categories":["Develop"],"content":"Service类型 ClusterIP 默认的，仅在集群内可用 NodePort 暴露端口到节点，提供了集群外部访问的入口 端口范围固定 30000 ~ 32767 LoadBalancer 需要负载均衡器（通常都需要云服务商提供，裸机可以安装 METALLB 测试） 会额外生成一个 IP 对外服务 K8S 支持的负载均衡器：负载均衡器 Headless 适合数据库 clusterIp 设置为 None 就变成 Headless 了，不会再分配 IP，后面会再讲到具体用法 官网文档 ","date":"2022-09-22","objectID":"/k8s/:5:3","tags":["k8s","DevOps"],"title":"K8S","uri":"/k8s/"},{"categories":["Develop"],"content":"Controller Deployment 管理pod的 selector来识别是管理的相关pod apiVersion: apps/v1 kind: Deployment metadata: name: test-k8s spec: replicas: 2 selector: matchLabels: app: test-k8s template: metadata: labels: app: test-k8s spec: containers: - name: test-k8s image: ccr.ccs.tencentyun.com/k8s-tutorial/test-k8s:v1 # 镜像 Deployment1 Lable1 Pod1 Pod1 Deployment2 lable2 Pod2 Pod2 StatrfuSet 什么是 StatefulSet StatefulSet 是用来管理有状态的应用，例如数据库。 前面我们部署的应用，都是不需要存储数据，不需要记住状态的，可以随意扩充副本，每个副本都是一样的，可替代的。 而像数据库、Redis 这类有状态的，则不能随意扩充副本。 StatefulSet 会固定每个 Pod 的名字 特性： StatefulSet 特性Service 的 CLUSTER-IP 是空的， Pod 名字也是固定的。Pod 创建和销毁是有序的， 创建是顺序的，销毁是逆序的。 job \u0026 cron job ","date":"2022-09-22","objectID":"/k8s/:5:4","tags":["k8s","DevOps"],"title":"K8S","uri":"/k8s/"},{"categories":["Develop","Tools"],"content":"desc","date":"2022-09-10","objectID":"/gitlog/","tags":["github"],"title":"Gitlog","uri":"/gitlog/"},{"categories":["Develop","Tools"],"content":"Git Changelog 原理/思路其实很简单，通过git log指令生成的日志。筛选出提交记录，提交时间。 把这些内容提取出来，按照md格式写入发布文件中（changelog中） 具体的筛选操作需要借助 format指令取操作。 ","date":"2022-09-10","objectID":"/gitlog/:0:0","tags":["github"],"title":"Gitlog","uri":"/gitlog/"},{"categories":["Develop","Tools"],"content":"gitlog Format 默认git log 出来的格式并不是特别直观，很多时候想要更简便的输出更多或者更少的信息，这里列出几个git log的format。可以根据自己的需要定制。 git log命令可一接受一个–pretty选项，来确定输出的格式. 比如 ： 如果我们只想输出hash. git log --pretty=format:\"%h\" #也可以直接使用format #e.g. git log --format=%B%aD Sat, 10 Sep 2022 16:03:16 +0800 修改文章排序 Sat, 10 Sep 2022 02:23:41 +0800 修改aidraw图片 Sat, 10 Sep 2022 01:08:54 +0800 修改aidraw Sat, 10 Sep 2022 00:43:50 +0800 添加作者链接 详细 命令 ： %H: commit hash %h: 缩短的commit hash %T: tree hash %t: 缩短的 tree hash %P: parent hashes %p: 缩短的 parent hashes %an: 作者名字 %aN: mailmap的作者名字 (.mailmap对应，详情参照git-shortlog(1)或者git-blame(1)) %ae: 作者邮箱 %aE: 作者邮箱 (.mailmap对应，详情参照git-shortlog(1)或者git-blame(1)) %ad: 日期 (–date= 制定的格式) %aD: 日期, RFC2822格式 %ar: 日期, 相对格式(1 day ago) %at: 日期, UNIX timestamp %ai: 日期, ISO 8601 格式 %cn: 提交者名字 %cN: 提交者名字 (.mailmap对应，详情参照git-shortlog(1)或者git-blame(1)) %ce: 提交者 email %cE: 提交者 email (.mailmap对应，详情参照git-shortlog(1)或者git-blame(1)) %cd: 提交日期 (–date= 制定的格式) %cD: 提交日期, RFC2822格式 %cr: 提交日期, 相对格式(1 day ago) %ct: 提交日期, UNIX timestamp %ci: 提交日期, ISO 8601 格式 %d: ref名称 %e: encoding %s: commit信息标题 %f: sanitized subject line, suitable for a filename %b: commit信息内容 %N: commit notes %gD: reflog selector, e.g., refs/stash@{1} %gd: shortened reflog selector, e.g., stash@{1} %gs: reflog subject %Cred: 切换到红色 %Cgreen: 切换到绿色 %Cblue: 切换到蓝色 %Creset: 重设颜色 %C(…): 制定颜色, as described in color.branch.* config option %m: left, right or boundary mark %n: 换行 %%: a raw % %x00: print a byte from a hex code %w([[,[,]]]): switch line wrapping, like the -w option of git-shortlog(1) ","date":"2022-09-10","objectID":"/gitlog/:1:0","tags":["github"],"title":"Gitlog","uri":"/gitlog/"},{"categories":["Develop","Tools"],"content":"其他内容的嵌入思路 ","date":"2022-09-10","objectID":"/gitlog/:2:0","tags":["github"],"title":"Gitlog","uri":"/gitlog/"},{"categories":["Develop","Tools"],"content":"version 可以通过项目的配置文件，配置版本号。在生成changelog脚本读取配置文件的版本号或者其他当前版本信息。 ","date":"2022-09-10","objectID":"/gitlog/:2:1","tags":["github"],"title":"Gitlog","uri":"/gitlog/"},{"categories":["Develop","Tools"],"content":"link to change git log --format=%B%H%aD 504b9f726d20343a59624ebefa8b50bd7897fd1dSat, 10 Sep 2022 16:03:16 +0800 修改文章排序 eab956775923e7297300f6728f97ef2d1b9ccaa6Sat, 10 Sep 2022 02:23:41 +0800 修改aidraw图片 1fee031181cd00e6d3ef87b1f9a2f525aacecdf3Sat, 10 Sep 2022 01:08:54 +0800 修改aidraw 修改输出格式，获取提交的hash值，通过链接拼接，可以直接定位到修改位置。 ","date":"2022-09-10","objectID":"/gitlog/:2:2","tags":["github"],"title":"Gitlog","uri":"/gitlog/"},{"categories":["Develop","Tools"],"content":"其他信息 一样的思路，修改–format的思路，通过拼接不同的信息指令。 案例：https://github.com/Ellioben/generate-gitlog ","date":"2022-09-10","objectID":"/gitlog/:2:3","tags":["github"],"title":"Gitlog","uri":"/gitlog/"},{"categories":["Develop"],"content":"desc","date":"2022-08-10","objectID":"/linux/","tags":["linux"],"title":"Linux","uri":"/linux/"},{"categories":["Develop"],"content":"开发常用 持续更新… ls cd pwd echo mv rm x.txt rm x.txt foo.txt rm -r cp -r dir1 dir2 scp -r mkdir -p df man man pwd man -h ls -h man --help #查看文件内容 cat (Concatenate and print Files) cat a.txt cat a.txt b.txt cat \u003c a.txt # head and tail (head 10 line ,last 10 line ) head a.txt tail a.txt tail -n 5 a.txt tail -f a.txt # / 查找 man less | grep -n sim ##wc 统计单词 word,line and byte count man pwd | wc man wc | wc ","date":"2022-08-10","objectID":"/linux/:1:0","tags":["linux"],"title":"Linux","uri":"/linux/"},{"categories":["Develop"],"content":"chomd chmod +X chmod: (Change Mode)改变文件的权限 chmod +x foo #增加可执行权限/ +W +r chmod -x foo #移除可执行权限/ -W-r chmod 740 foo # 把foo的权限设置成740 Owner: 7 = 1 + 2 + 4 = 可执行+可写+ 可读 Group: 4 = 4 = 可读 Others： 0 = 没有任何权限常见： ###常见 644 -rw-r--r-- # default 755 -rwxr-Xr-X 777 -rwxrwxrwx # 危险! use chown/chgrp instead #添加可执行权限 chomd +x xxx.py ll total 16 -rw-r--r-- 1 obsidianxiexxx staff 21B 7 30 01:13 hellow.txt -rw-r--r-- 1 obsidianxiexxx staff 316B 7 30 01:15 that.txt 可读可写 #添加可执行权限 chomd +x that.txt ./that.txt ./that.txt: line 1: syntax error near unexpected token `Move' ./that.txt: line 1: ` (That is, CONTROL and LEFTARROW simultaneously.) Move the cur-' ~/repositories/linux-command #就算修改名字后缀，也不影响执行情况。 mv that.txt that ~/repositories/linux-command ./that ./that: line 1: syntax error near unexpected token `Move' ./that: line 1: ` (That is, CONTROL and LEFTARROW simultaneously.) Move the cur-' PATH=$PATH:$PWD ","date":"2022-08-10","objectID":"/linux/:2:0","tags":["linux"],"title":"Linux","uri":"/linux/"},{"categories":["Develop"],"content":"交互式文件编辑 nano vim 还有其他交互式工具 ","date":"2022-08-10","objectID":"/linux/:3:0","tags":["linux"],"title":"Linux","uri":"/linux/"},{"categories":["Develop"],"content":"Which \u0026 环境变量$PATH 可以查找可执行文件 which app echo $PATH #全局可执行文件 $PATH环境变量+ which命令 PATH=$PATH: $PWD echo $PATH :/Users/huahua/cmd2 $PATH：以：分割的文件夹列表 从哪里去找可执行文件(按照文件夹的顺序查找) #把当前目录追加到PATH中 which: locate a program file in user's path % which my_echo /Users/huahua/cmd2/my_echo my_echo hello world! # Runs from anywhere Hello world! ","date":"2022-08-10","objectID":"/linux/:4:0","tags":["linux"],"title":"Linux","uri":"/linux/"},{"categories":["Develop"],"content":"interpreter #!/usr/bin/env python3 Shebang: #! SharpBang or haSHbang # # 使用哪个解释器(interpreter)去解释/运行脚本 必须放在第一行，并使用绝对路径 #!/bin/sh #!/bin/bash #!/usr/bin/perl #!/usr/bin/php % which python3 /Library/Frameworks/Python. framework/Versions/3.8/bin/python3 # 设置环境,并运行python3 #!/usr/bin/env python3 ","date":"2022-08-10","objectID":"/linux/:5:0","tags":["linux"],"title":"Linux","uri":"/linux/"},{"categories":["Develop"],"content":"Command-line Tools 创建处理管道 下载数据 可以在一个github rozim/ChessData上下载测试数据 读取速度测试 #*.pgn以参数列表的形式返回所有匹配的文件 cat 1。pgn 2。pgn 。。 100。gpn /dev/nul1 是一个设备文件，它丢弃一切写入的数据但返回写入成功。 cat *.pgn \u003e /dev/null #cat即读又是写，如果不是null，读和写或影响只读速度，所以写到黑洞里 定向到null是一个黑洞：丢数据。通常来测试硬盘的读取速度 这将是文件处理速度的上限 ","date":"2022-08-10","objectID":"/linux/:6:0","tags":["linux"],"title":"Linux","uri":"/linux/"},{"categories":["Develop"],"content":"重定向管道 重定向 ：改变输入输出设备 标准输入\u003cstdin\u003e/标准输出\u003cstdout\u003e：控制台键盘/屏幕 echo hello \u003e hellow.txt #redirect to a file echo word \u003e\u003e hellow.txt #append to a file cat \u003c hellow.txt #use file as stdin \u003c\u003e read from file #########管道:前一个命令的标注输出作为下一个程序的标准输入 man less | grep sim man less | grep sim | grep That \u003e that.txt # a multiple pipes #.. yes：一直输出y yes AMD YES!' # -直输出 AMD YES! yes 'yes' \u003e yes.txt Usages: Skip user confirmation yes | sudo apt-get install ","date":"2022-08-10","objectID":"/linux/:7:0","tags":["linux"],"title":"Linux","uri":"/linux/"},{"categories":["Develop"],"content":"创建处理管道 管道中其实是并行执行的。 搜索指定行 cat *.pgn | grep \"Result\" 最简单的版本 cat *.pgn | grep \"Result\" sort uniq -c 知识点: sort对输入文本进行排序 uniq -C 统计每个独立行的出现次数仅对已排序文件有效 ","date":"2022-08-10","objectID":"/linux/:8:0","tags":["linux"],"title":"Linux","uri":"/linux/"},{"categories":["Develop"],"content":"多进程处理任务 管道’|‘中的命令其实是并行执行的。 sleep 3 | sleep 5 | echo '8' ","date":"2022-08-10","objectID":"/linux/:9:0","tags":["linux"],"title":"Linux","uri":"/linux/"},{"categories":["Develop"],"content":"find find ：查找文件，打印匹配文件名到标准输出 find * | grep test xargs ：将参数列表(文件名)分段并执行命令 -n 每次(最多)取几个参数 -P最多几个命令同时并行执行 最后再用一个mawk合并结果 ","date":"2022-08-10","objectID":"/linux/:10:0","tags":["linux"],"title":"Linux","uri":"/linux/"},{"categories":["Develop"],"content":"stress \u0026 top \u0026 ps ","date":"2022-08-10","objectID":"/linux/:11:0","tags":["linux"],"title":"Linux","uri":"/linux/"},{"categories":["Develop"],"content":"stress 不是电脑自带的。 stress给系统增加负载或者进行压力测试 -t/--timeout N # N秒后超时 -c/--cpu N #孵化N个worker,死循环运行sqrt() / CPU -i/--io N # 孵化N个worker,死循环运行sync() / IO -m/--vm N # 孵化NTworker,死循环运行malloc()/free() / Memory -d/--hdd N # 孵化N个worker,死循环运行write()/unlink() / Disk stress --cpu 8 --io 4 --vm 2 - -vm-bytes 128M --timeout 10s ","date":"2022-08-10","objectID":"/linux/:11:1","tags":["linux"],"title":"Linux","uri":"/linux/"},{"categories":["Develop"],"content":"top 显示或更新排序过的进程信息（按照排名显示，显示有限） 默认按照CPU占用率排序 ","date":"2022-08-10","objectID":"/linux/:11:2","tags":["linux"],"title":"Linux","uri":"/linux/"},{"categories":["Develop"],"content":"ps ps (Process Status)显示进程状态（所有进程） 默认只显示当前用户有控制终端的进程 ps aux # 显示所有进程，包括其他用户的 ps aux | grep Chrome | wc -l # 看一看Chrome起了多少个进程 ps aux | grep -i chrome | wc -l ","date":"2022-08-10","objectID":"/linux/:11:3","tags":["linux"],"title":"Linux","uri":"/linux/"},{"categories":["Develop"],"content":"Kill \u0026 killall kill 终止或者给进程发信号 kill - signal_number/- signal_name PID # 默认发送15/TERM (software termination signal) kill PID kill -9/-KILL PID #强力杀进程ه Killall按照名字终止进程 和kill一样，但是用名字作为参数 #如果是大众命令就有可能误伤 killall bash / killall Python killall -9 stress ","date":"2022-08-10","objectID":"/linux/:12:0","tags":["linux"],"title":"Linux","uri":"/linux/"},{"categories":["Develop"],"content":"command+c vs command+z 都能让程序“停止” Ctrl+C 向进程发送SIGINT中断信号，通常进程会终止 Ctrl+Z 想进程发送SIGTSTP停止信号，把前台进程放入后台并挂起 进程还存在 打开的端口还会被占用 ","date":"2022-08-10","objectID":"/linux/:13:0","tags":["linux"],"title":"Linux","uri":"/linux/"},{"categories":["Develop"],"content":"模拟客户端 linux：nc 模拟客户端连接 windows：curl 模拟客户端连接 ","date":"2022-08-10","objectID":"/linux/:14:0","tags":["linux"],"title":"Linux","uri":"/linux/"},{"categories":["Develop"],"content":"其他 iperf：网络性能测试工具。 traceroute：识别数据包到达主机的路径。 ss：获取有关socket的详细信息。 bmon：监控实时带宽。 dig：列出所有的DNS iftop：带宽情况统计工具。 tcpdump：网络数据包捕获和分析工具，堪称Linux下网络神器。 ip：分配和配置网络参数。 nmcli：用于进行网络连接故障排查。 vnstat：监控当前网络流量和网络带宽情况。 jps　//显示所有JAVA进程 jps -l //显示所有JAVA进程详情名 ","date":"2022-08-10","objectID":"/linux/:15:0","tags":["linux"],"title":"Linux","uri":"/linux/"},{"categories":["Develop"],"content":"desc","date":"2022-07-09","objectID":"/mycat/","tags":["database"],"title":"Mycat","uri":"/mycat/"},{"categories":["Develop"],"content":"待更新 ","date":"2022-07-09","objectID":"/mycat/:1:0","tags":["database"],"title":"Mycat","uri":"/mycat/"},{"categories":["Develop"],"content":"Nginx简单实用和案例 💭","date":"2022-03-07","objectID":"/nginx/","tags":["server"],"title":"Nginx简单实用和案例","uri":"/nginx/"},{"categories":["Develop"],"content":"Nginx 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。2011年6月1日，nginx 1.0.4发布。 其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。 Nginx 是一个安装非常的简单、配置文件非常简洁（还能够支持perl语法）、Bug非常少的服务。Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的升级。 Nginx代码完全用C语言从头写成。官方数据测试表明能够支持高达 50,000 个并发连接数的响应。 当然除了抗压以外还支持限流，自定义路由等等 ","date":"2022-03-07","objectID":"/nginx/:0:0","tags":["server"],"title":"Nginx简单实用和案例","uri":"/nginx/"},{"categories":["Develop"],"content":"反向代理 代理服务端/保护服务端 ","date":"2022-03-07","objectID":"/nginx/:1:0","tags":["server"],"title":"Nginx简单实用和案例","uri":"/nginx/"},{"categories":["Develop"],"content":"正向代理 代理客户端/保护客户端 ","date":"2022-03-07","objectID":"/nginx/:2:0","tags":["server"],"title":"Nginx简单实用和案例","uri":"/nginx/"},{"categories":["Develop"],"content":"负载均衡 Nginx提供的负载均衡策略有2种 内置策略和扩展策略 内置策略：轮迿，加权轮询， Ip hash。 扩展策略：自己定义，想怎么玩就怎么玩 ","date":"2022-03-07","objectID":"/nginx/:3:0","tags":["server"],"title":"Nginx简单实用和案例","uri":"/nginx/"},{"categories":["Develop"],"content":"内置策略 ","date":"2022-03-07","objectID":"/nginx/:4:0","tags":["server"],"title":"Nginx简单实用和案例","uri":"/nginx/"},{"categories":["Develop"],"content":"轮询 以次循环 ","date":"2022-03-07","objectID":"/nginx/:4:1","tags":["server"],"title":"Nginx简单实用和案例","uri":"/nginx/"},{"categories":["Develop"],"content":"加权轮询 根据权重 ","date":"2022-03-07","objectID":"/nginx/:4:2","tags":["server"],"title":"Nginx简单实用和案例","uri":"/nginx/"},{"categories":["Develop"],"content":"IP hash phash对客户端请求的i进行hash操作，然后根据hash结果将同一个客户端p的请求分发给同一台服务器进行处理，可以解决 session不共享的问题。 ","date":"2022-03-07","objectID":"/nginx/:4:3","tags":["server"],"title":"Nginx简单实用和案例","uri":"/nginx/"},{"categories":["Develop"],"content":"动静分离 动静分离：在我们的软件开发中，有些请求是需要后台处理的，有些请求是不需要经过后台处理的（如:css、htm、jpg、js等等文件），这些不需要经过后台处理的文件称为静态文件。让动态网站里的动态网页根据定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作。提高资源响应的速度 安装Nginx docker安装 下载包安装 tar -zxvf nginx-1.16.1.tar.gz #执行configure ./configure make #或 make install whereis nginx #发现nginx安装成功 ","date":"2022-03-07","objectID":"/nginx/:5:0","tags":["server"],"title":"Nginx简单实用和案例","uri":"/nginx/"},{"categories":["Develop"],"content":"启动验证 cd /usr/local/nginx/sbin/./nginx #启动 ./nginx -s stop #停止 ./nginx -s quit #安全退出 ./nginx -s reload #重新加载配置文件 ps aux|grep nginx #查看nginx进程 启动成功访问 服务器ip:80 http:80 https:443 注意： linux防火墙80端口有没有开 阿里云安全组的80端口放开 使用 nginx的配置文件是conf目录下的nginx.conf，默认配置的nginx监听的端口为80，如果80端口被占用可以修改为未被占用的端口即可。 当我们修改了nginx的配置文件nginx.conf 时，不需要关闭nginx后重新启动nginx，只需要执行命令 nginx -s reload 即可让改动生效 关闭nginx 如果使用cmd命令窗口启动nginx， 关闭cmd窗口是不能结束nginx进程的，可使用两种方法关闭nginx (1)输入nginx命令 nginx -s stop(快速停止nginx) 或 nginx -s quit(完整有序的停止nginx) (2)使用taskkill taskkill /f /t /im nginx.exe taskkill是用来终止进程的，/f是强制终止 ./t终止指定的进程和任何由此启动的子进程。/im示指定的进程名称 . 相关命令： # 开启 service firewalld start # 重启 service firewalld restart # 关闭 service firewalld stop # 查看防火墙规则 firewall-cmd --list-all # 查询端口是否开放 firewall-cmd --query-port=8080/tcp # 开放80端口 firewall-cmd --permanent --add-port=80/tcp # 移除端口 firewall-cmd --permanent --remove-port=8080/tcp #重启防火墙(修改配置后要重启防火墙) firewall-cmd --reload # 参数解释 1、firwall-cmd：是Linux提供的操作firewall的一个工具； 2、--permanent：表示设置为持久； 3、--add-port：标识添加的端口； ","date":"2022-03-07","objectID":"/nginx/:6:0","tags":["server"],"title":"Nginx简单实用和案例","uri":"/nginx/"},{"categories":["Develop"],"content":"配置 Nginx的主配置文件是nginx.conf，这个配置文件一共由三部分组成，分别为全局块、events块和http块。在http块中，又包含http全局块、多个server块。每个server块中，可以包含server全局块和多个location块。在同一配置块中嵌套的配置块，各个之间不存在次序关系。 配置文件支持大量可配置的指令，绝大多数指令不是特定属于某一个块的。同一个指令放在不同层级的块中，其作用域也不同，一般情况下，高一级块中的指令可以作用于自身所在的块和此块包含的所有低层级块。如果某个指令在两个不同层级的块中同时出现，则采用“就近原则”，即以较低层级块中的配置为准。比如，某指令同时出现在http全局块中和server块中，并且配置不同，则应该以server块中的配置为准。 整个配置文件的结构大致如下： #全局块 #user nobody; worker_processes 1; #event块 events { worker_connections 1024; } #http块 http { #http全局块 include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; #server块 server { #server全局块 listen 8000; server_name localhost; #location块 location / { root html; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } #这边可以有多个server块 server { ... } } ","date":"2022-03-07","objectID":"/nginx/:7:0","tags":["server"],"title":"Nginx简单实用和案例","uri":"/nginx/"},{"categories":["Develop"],"content":"配置解析 ######Nginx配置文件nginx.conf中文详解##### #定义Nginx运行的用户和用户组 user www www; #nginx进程数，建议设置为等于CPU总核心数。 worker_processes 8; #全局错误日志定义类型，[ debug | info | notice | warn | error | crit ] error_log /usr/local/nginx/logs/error.log info; #进程pid文件 pid /usr/local/nginx/logs/nginx.pid; #指定进程可以打开的最大描述符：数目 #工作模式与连接数上限 #这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。 #现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。 #这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。 worker_rlimit_nofile 65535; events { #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型 #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。 #补充说明： #与apache相类，nginx针对不同的操作系统，有不同的事件模型 #A）标准事件模型 #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll #B）高效事件模型 #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。 #Epoll：使用于Linux内核2.6版本及以后的系统。 #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。 #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。 use epoll; #单个进程最大连接数（最大连接数=连接数*进程数） #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。 worker_connections 65535; #keepalive超时时间。 keepalive_timeout 60; #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。 #分页大小可以用命令getconf PAGESIZE 取得。 #[root@web001 ~]# getconf PAGESIZE #4096 #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。 client_header_buffer_size 4k; #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。 open_file_cache max=65535 inactive=60s; #这个是指多长时间检查一次缓存的有效信息。 #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息. open_file_cache_valid 80s; #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。 #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location 这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态. open_file_cache_min_uses 1; #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件时记录cache错误. open_file_cache_errors on; } #设定http服务器，利用它的反向代理功能提供负载均衡支持 http { #文件扩展名与文件类型映射表 include mime.types; #默认文件类型 default_type application/octet-stream; #默认编码 #charset utf-8; #服务器名字的hash表大小 #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小. server_names_hash_bucket_size 128; #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。 client_header_buffer_size 32k; #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。 large_client_header_buffers 4 64k; #设定通过nginx上传文件的大小 client_max_body_size 8m; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。 #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。 sendfile on; #开启目录列表访问，合适下载服务器，默认关闭。 autoindex on; #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用 tcp_nopush on; tcp_nodelay on; #长连接超时时间，单位是秒 keepalive_timeout 120; #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。 fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; #gzip模块设置 gzip on; #开启gzip压缩输出 gzip_min_length 1k; #最小压缩文件大小 gzip_buffers 4 16k; #压缩缓冲区 gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0） gzip_comp_level 2; #压缩","date":"2022-03-07","objectID":"/nginx/:8:0","tags":["server"],"title":"Nginx简单实用和案例","uri":"/nginx/"},{"categories":["Develop"],"content":"Nginx配置生成器 https://www.digitalocean.com/community/tools/nginx ","date":"2022-03-07","objectID":"/nginx/:9:0","tags":["server"],"title":"Nginx简单实用和案例","uri":"/nginx/"},{"categories":["碎碎念"],"content":"第一个博客文的碎碎念 💭","date":"2021-09-07","objectID":"/demo/","tags":["xxx"],"title":"Start...","uri":"/demo/"},{"categories":["碎碎念"],"content":"记录 准备在这个博客准备记录一些自己的学习记录及分享，好用的工具推荐及用法，事情分享，电影，剧，还有数码等等… 后续还会准备英文版本.. 毕竟是第一个博文，也会在这篇文章上面记录一些看起来没用的东西，或者是提醒自己没事更新更新/待更新哪些类型有关的。 这里只是一个大概括，细节后续会更新在博客里。 ","date":"2021-09-07","objectID":"/demo/:1:0","tags":["xxx"],"title":"Start...","uri":"/demo/"},{"categories":["碎碎念"],"content":"工具类 Mac Notion zsh brew Bob ClashX mac的cron job Windows xxx ","date":"2021-09-07","objectID":"/demo/:2:0","tags":["xxx"],"title":"Start...","uri":"/demo/"},{"categories":["碎碎念"],"content":"技术类 这里相对来说会很多，弄清楚了会记录下来 ","date":"2021-09-07","objectID":"/demo/:3:0","tags":["xxx"],"title":"Start...","uri":"/demo/"},{"categories":["碎碎念"],"content":" 整理自己杂乱的笔记，把整理好的内容放在这个上面。这个有些复杂，往后放一放 mycat使用 AI绘画 nginx gitlog脚本生成器 区块链 springBean加载到spi 三色标记 限流算法 docker smart contract初步入门 Solidity go的协程原理 闭包 Grafana详细使用 pod生命周期详解 ","date":"2021-09-07","objectID":"/demo/:3:1","tags":["xxx"],"title":"Start...","uri":"/demo/"},{"categories":["碎碎念"],"content":"学习 英语，虽然很一般，不过还是记录下来。有空会持续添加上i18n版本的blog k8s 二次开发 ","date":"2021-09-07","objectID":"/demo/:4:0","tags":["xxx"],"title":"Start...","uri":"/demo/"},{"categories":["碎碎念"],"content":"数码产品 apple watch7 ","date":"2021-09-07","objectID":"/demo/:5:0","tags":["xxx"],"title":"Start...","uri":"/demo/"},{"categories":["碎碎念"],"content":"电影 哈利波特 ","date":"2021-09-07","objectID":"/demo/:6:0","tags":["xxx"],"title":"Start...","uri":"/demo/"},{"categories":["碎碎念"],"content":"电视剧 Loki 月光骑士 赛博朋克 鬼灭之刃 ","date":"2021-09-07","objectID":"/demo/:7:0","tags":["xxx"],"title":"Start...","uri":"/demo/"},{"categories":null,"content":"About Me 🤠","date":"2019-08-02","objectID":"/about/","tags":null,"title":"About Me 🤠","uri":"/about/"},{"categories":null,"content":"🚸 来自中国西安的小城市🌃，工作4年有余，上海，成都，广东都有工作过，对地域要求不高。 为人随性，简单，兴趣爱好广泛，喜欢分享有趣的事情。不限于生活，游戏🤠，数码，技术，电影，追剧，神话🔱，心理，哲学… 典型ENTP人格。 技术方面也会空闲佛系把文章写好上架，除了以下技术方面的内容外。后续还会有数码，旅游，文化，github上好玩的项目。xxx类事情的个人思路，电影，剧，动漫，冷门有用怪癖的网站等等… 主要从事java相关的工作，当然前端/相应的框架，go，python，shell，运维，区块链，web3相关技术的也在平时工作和学习中有被涉及到。 主要掌握的技术： ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About Me 🤠","uri":"/about/"},{"categories":null,"content":"🔸 语言 java,go,shell,python,js,vue,web3,html,css… java 开发，次熟悉 go 开发，Python小工具，Solidity简单的合约并部署上测试网做测试。 前端 JavaScript、JQuery、vue；echarts，element-ui，bootstrap 等等前端框架。 linux，容器化docker，k8s，shell。 ","date":"2019-08-02","objectID":"/about/:1:0","tags":null,"title":"About Me 🤠","uri":"/about/"},{"categories":null,"content":"🔸 技术框架： spring，springboot，nacos，springmvc，springcloud/dubbo+zookeeper，mybatisplus，hibernate等等一些常用的java框架使用和搭建。JVM 优化，JVM 垃圾回收机制。 go 多线程方面使用，GPM，开发有关的框架gin/gorm/hertz/wire等等做架构使用（go 框架使用偏向于 github 上查文档学习和使用）有空也会记录上。 DDD 泛谈 ","date":"2019-08-02","objectID":"/about/:2:0","tags":null,"title":"About Me 🤠","uri":"/about/"},{"categories":null,"content":"🔸 DB： Oracal、Mysql、sqlserver sql 优化语句调优和数据库性能优化。 其它类型的数据库使用： Redis：基本使用，对容错机制和哨兵机制，分布式锁等等；列式存储 clickhouse ： 基本的 sql； 对象存储：TOS、MinIO； 搭建（ELK） Kabana，ES，LK Grafana，Matedata 等数据可视化的一些操作。 ","date":"2019-08-02","objectID":"/about/:3:0","tags":null,"title":"About Me 🤠","uri":"/about/"},{"categories":null,"content":"🔸 服务： Nignx 、分布式服务和网关框架的搭建、zookeeper 集群搭建… docker 容器化服务构建、部署和使用，docker compose/docker swarm/ k8s 。 DevOps 的理念，CI/CD 的简单构建，k8s 在 DevOps 发挥的作用，istio …。 熟练 CNCF 基金会的开源项目 Grafana 可视化系统监测，有空安排到博客上。 ","date":"2019-08-02","objectID":"/about/:4:0","tags":null,"title":"About Me 🤠","uri":"/about/"},{"categories":null,"content":"🔸 区块链： 区块链的共识机制，solidity 语法， Remix 部署简单的合约并通过自己私有网络实现钱包和合约之间的测试交易。 web3 与合约之间的 ABI 调用，可实现简单的页面，matemask 与区块链网络之间的交互。 对区块链有关的比较感兴趣，关注各种与区块链有关的资讯，中心化、去中心化交易所，opensea+IPFS，链游… 等有空闲时间都会陆续续放上文章…. ","date":"2019-08-02","objectID":"/about/:5:0","tags":null,"title":"About Me 🤠","uri":"/about/"}]